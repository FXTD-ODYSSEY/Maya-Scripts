//
//  Alias|Wavefront Script File
//  MODIFY THIS AT YOUR OWN RISK
//
//
//  Creation Date:  14 November 1997
//  Original Author:         mbaer
//
//  Procedure Name:
//      fire
//
//
//  Description:
//      
//              This effect is set up for both sw and hardware 
//              rendering. But is ready for SW rendering by default.
//              The majority of the controls are accessable through the
//              channel box by seleting the fire particle that
//              is created. If you need to change the display
//              type from cloud (SW) to multiStreak (HW) simply
//              open up the Attribute Editor. Ramps are created
//              to control the change of color, opacity, transparency,
//              and incandescance which are accessable through
//              the multilister.
//



// Find the array mapper or ramp node.
//
proc string findRamp(string $particleAttribute, string $type)
{
    string $ramps[] = `listConnections -source true $particleAttribute`;
    if ($type == "ramp")
        $ramps = `listConnections -source true ($ramps[0] + ".computeNode")`;

    return $ramps[0];
}


// Set up for software rendering.
//
proc string[] fireShader(string $rgbRamp, string $turbulence, string $name)
{
    // Set up the basic software shader.
    //
    string $cloud = `shadingNode -n ($name + "Cloud") -asShader particleCloud`;
    string $shadingGroup = `sets -r true -nss true -em -n ($cloud+ "SG")`;
    connectAttr -f ($cloud + ".outColor") ($shadingGroup + ".volumeShader");

    // Set some of the cloud shading node attributes.
    //
    setAttr ($cloud + ".glowIntensity") 0.35;
    setAttr ($cloud + ".density") 3.008;
    setAttr ($cloud + ".noiseFreq") 0.504;
    setAttr ($cloud + ".noiseAspect") -0.6748;

    // rgb ramp setup
    //
    string $ramp = $rgbRamp;
    string $place2d = `shadingNode -asUtility place2dTexture`;
    string $ageMapper = `shadingNode -at -asUtility particleAgeMapper`;

    //
    //
    connectAttr ($place2d + ".outUV") ($ramp + ".uv");
    connectAttr ($place2d + ".outUvFilterSize") ($ramp + ".uvFilterSize");
    connectAttr -f ($ageMapper + ".outUvCoord") ($place2d + ".uvCoord");
    connectAttr -f ($ramp + ".outColor") ($cloud + ".color");
    setAttr ($ageMapper + ".relativeAge") 1;

    // transparency ramp setup
    //
    $ramp = `shadingNode -n ($name + "TransRamp") -asTexture ramp`;
    $place2d = `shadingNode -asUtility place2dTexture`;

    //
    //
    connectAttr ($place2d + ".outUV") ($ramp + ".uv");
    connectAttr ($place2d + ".outUvFilterSize") ($ramp + ".uvFilterSize");
    connectAttr -f ($ageMapper + ".outUvCoord") ($place2d + ".uvCoord");
    connectAttr -f ($ramp + ".outColor") ($cloud + ".transparency");

    // Set some of the attributes of the ramp.
    //
    setAttr ($ramp + ".colorEntryList[4].color") -type double3 1 1 1;
    setAttr ($ramp + ".colorEntryList[4].position") 1;
    setAttr ($ramp + ".colorEntryList[5].color") -type double3 0.9 0.9 0.9;
    setAttr ($ramp + ".colorEntryList[5].position") 0.49;
    setAttr ($ramp + ".colorEntryList[6].color") -type double3 1 1 1;
    setAttr ($ramp + ".colorEntryList[6].position") 0;
    setAttr ($ramp + ".interpolation") 4;

    // incandescense ramp setup
    //
    $ramp = `shadingNode -n ($name + "IncanRamp") -asTexture ramp`;
    $place2d = `shadingNode -asUtility place2dTexture`;

    //
    //
    connectAttr ($place2d + ".outUV") ($ramp + ".uv");
    connectAttr ($place2d + ".outUvFilterSize") ($ramp + ".uvFilterSize");
    connectAttr -f ($ageMapper + ".outUvCoord") ($place2d + ".uvCoord");
    connectAttr -f ($ramp + ".outColor") ($cloud + ".incandescence");

    // Set some more of the attributes of the ramp.
    //
    setAttr ($ramp + ".colorEntryList[0].color") -type double3 0 0 0;
    setAttr ($ramp + ".colorEntryList[0].position") 1;
    setAttr ($ramp + ".colorEntryList[5].color") 
        -type double3 0.1108401 0.0842115 0.01146095;
    setAttr ($ramp + ".colorEntryList[5].position") 0.8551;
    setAttr ($ramp + ".colorEntryList[2].color") 
        -type double3 0.7568628 0.5750318 0.0782602;
    setAttr ($ramp + ".colorEntryList[2].position") 0.6001;
    setAttr ($ramp + ".colorEntryList[3].color") 
        -type double3 0.7121781 0.439115 0.1845021;
    setAttr ($ramp + ".colorEntryList[3].position") 0.4051;
    setAttr ($ramp + ".colorEntryList[4].color") -type double3 0 0 0;
    setAttr ($ramp + ".colorEntryList[4].position") 0;
    setAttr ($ramp + ".interpolation") 4;

    // create blob map
    //
    string $crater = `shadingNode -asTexture crater`;
    string $place3d = `shadingNode -asUtility place3dTexture`;

    //
    //
    connectAttr ($place3d + ".wim[0]") ($crater + ".pm");
    connectAttr -f ($crater + ".outColor") ($cloud + ".blobMap");

    // Set some of the attributes of the crater texture.
    //
    setAttr ($crater + ".shaker") 14.4712;
    setAttr ($crater + ".channel1") -type double3 1 0.6815069 0.3290193;
    setAttr ($crater + ".channel2") 
        -type double3 0.2509804 0.1372549 0.08627451;
    setAttr ($crater + ".channel3") 
        -type double3 0.2196078 0.1294118 0.04313726;
    setAttr ($crater + ".melt") 0.05;
    setAttr ($crater + ".balance") 0.5691;
    setAttr ($crater + ".frequency") 0.732;

    // Hide the place3d but make a expression on its translateY so that it is
    // dependant on the turbulence phase.
    //
    hide $place3d;
    expression -s (
        $place3d + ".translateY = " + $turbulence + ".phase * 2;\n"
        ) -name ($name + "Place3dTransExpr") -o $place3d -ae 1 -uc all;

    // Return the name of the shading group and the place3d.
    //
    return {$shadingGroup, $place3d};
}

// Light the passed in object on fire and return the name of the fire
// particles.
//
proc string light(string $object, int $objects)
{
    // Since the object name is in its long form (eg:  |groupA|nurbsSphere1)
    // we need the short form of the object name (eg:  nurbsSphere1) to use as
    // a base name for the objects that are to be created.
    //
    string $temp[];
    tokenize($object, "|", $temp);
    string $name = $temp[size($temp) - 1];

    // Create surface emitter on selected geometry.
    //
    $temp = `emitter -type surface -r 20 -spd 1 -nsp 3 -tsp 0.1 $object`;
    string $emitter = $object;
    hide ($emitter + "|" + $temp[1]);
    print("// Adding surface emitter to: " + $object + ".\n");

    // Create fire particle object to be connected to surface emitter and get
    // the particle and particle shape names.
    //
    if ($objects == 1)
        $temp = `particle -name ($name + "Fire")`;
    else
        $temp = `particle -name "objectsFire"`;

    // Get the particle and particle shape name and have the emitter emit into
    // the particle object.
    //
    string $fire = "|" + $temp[0];
    string $fireShape = $fire + "|" + $temp[1];
    connectDynamic -em $emitter $fire;
    print("// Created " + $fire + " to be emitted from " + $object + ".\n");

    // Create gravity and turbMag fields
    //
    $temp = `gravity -n gravity -pos 0 0 0 -dx 0 -dy 1 -dz 0`;
    string $gravity = "|" + $temp[0];
    hide ($gravity + "|" + $temp[1]);
    $temp = `turbulence -n turbulence -mxd -1 -att 0 -pos 0 0 0 -p 0 -pv 1`;
    string $turbulence = "|" + $temp[0];
    hide ($turbulence + "|" + $temp[1]);

    // Create drag field
    //
    $temp = `drag -n drag -pos 0 0 0 -m 11 -dx 0 -dy 0 -dz 0`;
    string $drag = "|" + $temp[0];
    hide ($drag + "|" + $temp[1]);
    connectDynamic -f $gravity -f $drag -f $turbulence $fire; 

    // Setup fire particle attributes - for hw render only.
    // This includes displaying the particles as MultiStreaks and setting
    // certain corresponding attributes.
    //
    setAttr ($fireShape + ".renderType") 8; 
    addAttr -is 1 -ln "colorAccum" -at bool -dv true $fireShape;
    addAttr -is 1 -ln "useLighting" -at bool -dv false $fireShape;
    addAttr -is 1 -ln "lineWidth" -at long -min 1 -max 20 -dv 1 $fireShape;
    addAttr -is 1 -ln "multiCount" -at long -min 1 -max 60 -dv 10 $fireShape;
    addAttr -is 1 -ln "multiRadius" -at "float" -min 0 -max 10 $fireShape;
    addAttr -is 1 -ln "tailFade" -at "float" -min 0 -max 1 -dv 0 $fireShape;
    addAttr -is 1 -ln "tailSize" -at "float" -min 0 -max 30 -dv 3 $fireShape;
    addAttr -is 1 -ln "normalDir" -at long -min 1 -max 3 -dv 2 $fireShape;
    addAttr -ln "rgbPP" -dt vectorArray $fireShape;
    addAttr -ln "opacityPP" -dt doubleArray $fireShape;
    addAttr -ln "lifespanPP" -dt doubleArray $fireShape;

    // Setup fire particle attributes - for sw render only.
    //
    addAttr -is true -ln "threshold" -at "float" -min 0 -max 1 $fireShape;
    addAttr -is true -ln "radius" -at "float" -min 0 -max 20 $fireShape;

    // Set some attributes of the RGB ramp.
    //
    arrayMapper -target $fireShape -destAttr rgbPP -inputU rgbUPP 
        -inputV ageNormalized -type ramp;
    string $ramp = findRamp(($fireShape + ".rgbPP"), "ramp");

    // Since the fire name is in its long form (eg:  |groupA|nurbsSphere1Fire)
    // we need the short form of the fire name (eg:  nurbsSphere1Fire) to 
    // use as a base name for the objects that are to be created.
    //
    int $index = tokenize($fire, "|", $temp);
    string $fireName = $temp[$index - 1];
    $ramp = `rename $ramp ($fireName + "RGBramp")`;

    // Set some attributes of the RGB ramp.
    //
    setAttr ($ramp + ".colorEntryList[2].color") 
        -type double3 0.574 0.274 0.149;
    setAttr ($ramp + ".colorEntryList[2].position") 1;
    setAttr ($ramp + ".colorEntryList[1].color") 
        -type double3 0.676 0.439 0.144;
    setAttr ($ramp + ".colorEntryList[1].position") 0.5;
    setAttr ($ramp + ".colorEntryList[0].color") 
        -type double3 0.739 0.559 0.173;
    setAttr ($ramp + ".colorEntryList[0].position") 0.0;

    // Set up sw render particle shader.
    //
    $temp = fireShader($ramp, $turbulence, $fireName);
    string $shadingGroup = $temp[0];
    string $place3d = $temp[1];
    sets -e -forceElement $shadingGroup $fire;
    print ("// Name of shading group: " + $shadingGroup + "\n");

    // Set up opacityPP ramp.
    //
    arrayMapper -target $fireShape -destAttr opacityPP 
        -inputV ageNormalized -type ramp;
    $ramp = findRamp(($fireShape + ".opacityPP"), "ramp");
    $ramp = `rename $ramp ($fireName + "OpacityRamp")`;

    // Set some of the ramp attributes.
    //
    setAttr ($ramp + ".interpolation") 4;
    setAttr ($ramp + ".colorEntryList[2].color") -type double3 0 0 0;
    setAttr ($ramp + ".colorEntryList[2].position") 1;
    setAttr ($ramp + ".colorEntryList[1].color") -type double3 1 1 1;
    setAttr ($ramp + ".colorEntryList[1].position") 0.5;
    setAttr ($ramp + ".colorEntryList[0].color") -type double3 0 0 0;
    setAttr ($ramp + ".colorEntryList[0].position") 0.0;

    // Create user controls on the control object.
    //
    addAttr -ln heat -at double -min 0 -max 5 -dv 0.6 $fire;
    addAttr -ln life -at double -min 0 -max 10 -dv 1 $fire;
    addAttr -ln spots -at double -min 0 -max 50 -dv 0.8 $fire;
    addAttr -ln gravityMag -at double -min 0 -max 500 -dv 85 $fire;
    addAttr -ln turbMag -at double -min 0 -max 500 -dv 100 $fire;
    addAttr -ln turbFreq -at double -min 0 -max 5 -dv .95 $fire;
    addAttr -ln turbPhase -at double -min 0 -max 10 -dv 5 $fire;
    addAttr -ln fireScale -at double -min 0 -max 1000 -dv 1 $fire;
    addAttr -ln emission -at double -min 0 -max 1000 -dv 25 $fire;

    // Make all of the user attributes of the fire keyable.
    //
    setAttr -keyable on ($fire + ".heat");
    setAttr -keyable on ($fire + ".life");
    setAttr -keyable on ($fire + ".spots");
    setAttr -keyable on ($fire + ".gravityMag");
    setAttr -keyable on ($fire + ".turbMag");
    setAttr -keyable on ($fire + ".turbFreq");
    setAttr -keyable on ($fire + ".turbPhase");
    setAttr -keyable on ($fire + ".emission");
    setAttr -keyable on ($fire + ".fireScale");

    // If there are more than one object then create a specific emission
    // modifier attribute for this first emitter object.
    //
    if ($objects > 1)
    {
        addAttr -ln $name -at double -min 0 -max 10 -dv 1 $fire;
        setAttr -keyable on ($fire + "." + $name);
    }

    // Make the all of the other fire attributes, except visibility, not 
    // keyable so that they are not visible in the Channel Box.
    //
    setAttr -keyable off ($fire + ".tx");
    setAttr -keyable off ($fire + ".ty");
    setAttr -keyable off ($fire + ".tz");
    setAttr -keyable off ($fire + ".rx");
    setAttr -keyable off ($fire + ".ry");
    setAttr -keyable off ($fire + ".rz");
    setAttr -keyable off ($fire + ".sx");
    setAttr -keyable off ($fire + ".sy");
    setAttr -keyable off ($fire + ".sz");

    // Scale the crater blob map.
    //
    expression -s (
        "scaleX = 2.0 * " + $fire + ".fireScale;\n" +
        "scaleY = 5.0 * " + $fire + ".fireScale;\n" +
        "scaleZ = 2.0 * " + $fire + ".fireScale;\n"
        ) -name ($fireName + "Place3dScaleExpr") -o $place3d;

    // The renderType of the fire should be Cloud (8) for software
    // rendering, otherwise it shoud be MultiStreak (1) for hardware
    // rendering.
    //
    expression -s (
        "multiRadius = 0.3 * " + $fire + ".fireScale;\n" +
        "radius = " + $fire + ".fireScale;\n"
        ) -name ($fireName + "ParticleExpr") -o $fireShape;

    // Connect up some attributes to some of the basic fire we just made.
    //
    string $arrayMap = findRamp(($fireShape + ".opacityPP"), "map");
    connectAttr -f ($fire + ".heat") ($arrayMap + ".maxValue");

    // The magnitude of the gravity is just the scaled speed of the fire.
    //
    expression -s (
        "magnitude = " + $fire + ".gravityMag * " + $fire + ".fireScale;\n"
        ) -name ($fireName + "GravityExpr") -o $gravity;

    // Hook up the user fire to the fire particle fire by way of
    // an expression.
    //
    expression -s (
        "magnitude = " + $fire + ".turbMag * " + $fire
            + ".fireScale;\n" +
        "frequency = " + $fire + ".turbFreq / " + $fire + ".fireScale;\n" +
        "phase = -time * " + $fire + ".turbPhase * " + $fire
            + ".fireScale;\n"
        ) -name ($fireName + "TurbulenceExpr") -o $turbulence;

    // If there is only one object to light on fire then fire the emission
    // with just the scaled fire value.  Otherwise, also factor in the
    // object emission fire.
    //
    if ($objects == 1)
        expression -s (
            "rate = " + $fire + ".emission / pow(" + $fire 
                + ".fireScale, 2);\n"
            ) -name ($fireName + "EmitterExpr") -o $emitter;
    else
        expression -s (
            "rate = " + $fire + ".emission * " + $fire + "."
                + $name + " / pow(" + $fire + ".fireScale, 2);\n"
            ) -name ($name + "FireEmitterExpr") -o $emitter;

    // Add creation expression for all the elements of the fire.
    //
    dynExpression -s (
        $fireShape + ".lifespanPP = (dnoise(" + $fireShape + ".position * (" 
            + $fire + ".spots / " + $fire + ".fireScale) + vector(-3 "
            + "* <<0, time, 0>>)) + .1) * " + $fire + ".life;\n"
            + $fireShape + ".rgbUPP = rand(1);\n"
        ) -c $fireShape;

    // Parent the fire components to the fire and return the name of 
    // the fire.
    //
    //
    print ("// Main controls are on object: " + $fire + ".\n");
    parent $gravity $turbulence $drag $place3d $fire;
    return $fire;
}


// This is the procedure that the user should execute.  It sets all of the
// selected objects on fire but makes a common control object which is on the
// particles that are created.
//
global proc fire()
{
    // Make a temp string array variable to hold contents of things that
    // return string arrays and determine the selected objects.
    //
    waitCursor -state on;
    string $selected[] = `ls -l -sl`;
    int $numberSelected = size($selected);

    // There needs to be at least one object selected to light on fire.
    //
    string $fire;
    if ($numberSelected > 0)
        $fire = light($selected[0], $numberSelected);
    else
        print("Error:  Select an object first.\n");

    // Make some variables for the following loop.
    //
    int $index;
    string $name;
    string $object;
    string $temp[];

    // Since the fire name is in its long form (eg:  |groupA|nurbsSphere1Fire)
    // we need the short form of the fire name (eg:  nurbsSphere1Fire) to 
    // use as a base name for the objects that are to be created.
    //
    $index = tokenize($fire, "|", $temp);
    string $fireName = $temp[$index - 1];

    // For all additionally selected objects light them on fire using the
    // fire of of first object that was lit.  However make an
    // additional control for the emission rate multiplier for each new
    // emitter object.
    //
    for ($index = 1; $index < $numberSelected; $index++)
    {
        // Make the current object an emitter and make it emit into the fire
        // particle object.
        //
        $object = $selected[$index];
        $temp = `emitter -typ surf -r 20 -spd 1 -nsp 3 -tsp .1 $object`;
        string $emitter = $object;
        hide ($emitter + "|" + $temp[1]);
        connectDynamic -em $emitter $fire;

        // Since the object name is in its long form 
        // (eg:  |groupA|nurbsSphere1) we need the short form of the 
        // object name (eg:  nurbsSphere1) to use as a base name for 
        // the objects that are to be created.
        //
        tokenize($object, "|", $temp);
        $name = $temp[size($temp) - 1];

        // Add a keyable attribute to the fire object named after 
        // the current object to control its emission rate.  Then make an 
        // expression that factors in this attribute along with the scaled 
        // control value to actually do this.
        //
        addAttr -ln $name -at double -min 0 -max 10 -dv 1 $fire;
        setAttr -keyable on ($fire + "." + $name);
        expression -s (
            "rate = " + $fire + ".emission * " + $fire + "."
                + $name + " / pow(" + $fire + ".fireScale, 2);\n"
            ) -name ($name + "FireEmitterExpr") -o $emitter;
    }

    // Select the fire so that the user can control the fire they just 
    // created.
    //
    select $fire;
    waitCursor -state off;
}
