//
// Copyright (C) 1998-1999 Alias|Wavefront,
// a division of Silicon Graphics Limited.
//
// The information in this file is provided for the exclusive use of the
// licensees of Alias|Wavefront.  Such users have the right to use, modify,
// and incorporate this code into other products for purposes authorized
// by the Alias|Wavefront license agreement, without fee.
//
// ALIAS|WAVEFRONT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
// INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
// EVENT SHALL ALIAS|WAVEFRONT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
// CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
// DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.
//
// Alias|Wavefront Script File
// MODIFY THIS AT YOUR OWN RISK
//
//  Creation Date: 1997
//  Author:        Barb B. 
//
//
//  Description:
//      This script fixes some problems that make it difficult to edit sets.
//
//  To use:
//		Select shape (or shapes) and enter fixSets in the ScriptEditor.
//      Results are printed in the ScriptEditor.
//

global proc unhookIndexedDeformer(string $deformer, int $index)
{
	string $sa[] = `ls -type geometryFilter $deformer`;
	if (0 == size($sa)) {
		error("unhookDeformer: "+ $deformer + " is not a deformer node.\n");
		return;
	}

	$conns = `listConnections -p true ($deformer+".og["+$index+"]")`;
	if (size($conns) == 0) {
		error("unhookDeformer: no out connection from "+($deformer+".og["+$index+"]")+"\n");
		return;
	}
	string $defOut = $conns[0];

	$conns = `listConnections -p true ($deformer+".ip["+$index+"].ig")`;
	if (size($conns) == 0) {
		error("unhookDeformer: no in connection to "+($deformer+".ip["+$index+"].ig")+"\n");
		return;
	}
	string $defIn = $conns[0];

	disconnectAttr ($deformer+".og["+$index+"]") $defOut;
	disconnectAttr $defIn ($deformer+".ip["+$index+"].ig");
	connectAttr $defIn $defOut;
}

global proc int shapeHasDeformationHistory(string $shape)
//
//	Description:
//		Returns 1 if the given shape has deformers in its history.
//		Else returns 0.
//
{
	string $testInput[] = `ls -type controlPoint $shape`;
	if (0 == size($testInput)) {
		error("Invalid input to shapeHasDeformationHistory: "+$shape+"\n");
		return 0;
	}

	string $histPlug = historyPlug($shape,"");

	// make sure the object has history before starting the loop
	//
	string $conns[];
	int $result = 0;

	while(true) {
		$conns = `listConnections -p true $histPlug`;
		if (! size($conns)) {
			return 0;
		}
		
		// listConnections returns transform name for shapes, so make
		// sure we get the node name and not the transform
		//
		string $buffer[];
		tokenize($conns[0],".",$buffer);
		$obj = $buffer[0];

		string $filterCheck[] = `ls -type geometryFilter $obj`;
		if (size($filterCheck)) {
			return 1;
		}
		
		// get the name of the plug feeding the shape into this node
		//
		$histPlug = historyPlug($obj,$conns[0]);
		if ($histPlug == "") {
			// stop, we can't find any more history
			//
			return 0;
		}
	}
	return 0;
}

global proc int plugMultiIndex(string $plug)
//
//  Method:   int plugMultiIndex(string $plug)
//
//  Description:
//    Given a plug that contains a multiIndex, return the index
//
//    If no multiIndex is found, returns -1.
//	  If plug is a multi multi, returns the first multiIndex only.
//
{
	string $buffer[], $buffer2[];
	tokenize($plug,"[",$buffer);
	if (size($buffer) != 2) {
		return(-1);
	}
	tokenize($buffer[1],"]",$buffer2);
	return $buffer2[0];
}

global proc string historyPlug(string $node, string $plug)
//
//  Method: historyPlug(string $node, string $plug)
//
//  Description:
//  Given a $node and a $plug ($plug is optional on all
//  nodes except deformers), this method returns the name
//  of the plug that inputs the shape data into this
//  node.
//
//  If it does not recognize the node type of the given
//  node, it returns "".
//
//  Currently supported node types:
//   lattice, nurbsSurface, nurbsCurve, mesh, groupParts, deformers,
//   stitchSrf, trim, polyModifier, deleteComponent, makeGroup,
//	 detachSurface
//
{
	string $nt = nodeType($node);
	string $historyAttr = "";

	string $testSel[]= `ls -type geometryFilter $node`;
	string $testMM[]= `ls -type polyModifier $node`;	

	if      ($nt == "lattice")		{ $historyAttr = ".li"; }
	else if ($nt == "nurbsSurface")	{ $historyAttr = ".cr"; }
	else if ($nt == "nurbsCurve") 	{ $historyAttr = ".cr"; }
	else if ($nt == "stitchSrf") 	{ $historyAttr = ".is"; }
	else if ($nt == "trim")		 	{ $historyAttr = ".is"; }
	else if ($nt == "untrim")		{ $historyAttr = ".is"; }	
	else if ($nt == "transformGeometry")   { $historyAttr = ".ig"; }
	else if ($nt == "mesh") 		{ $historyAttr = ".i";  }
	else if ($nt == "groupParts")   { $historyAttr = ".ig"; }
	else if ($nt == "makeGroup")    { $historyAttr = ".ig"; }
	else if ($nt == "deleteComponent") { $historyAttr = ".ig"; }		
	else if ($nt == "insertKnotSurface") { $historyAttr = ".is"; }		
	else if ($nt == "detachSurface")   { $historyAttr = ".is"; }	
	else if (size($testSel)) {
		int $index = plugMultiIndex($plug);
		if ($index == -1) {
			return("");
		}
		$historyAttr = (".input["+$index+"].inputGeometry");		
	} else if (size($testMM)) {
		$historyAttr = ".inputPolymesh";
	} else {
		print("Stopped traversing history at "+$nt+" plug "+$plug+"\n");
		return("");
	}

	return ($node+$historyAttr);
}

//
//  Method: futurePlug(string $node, string $plug)
//
//  Description:
//  Given a $node and a $plug ($plug is optional on all
//  nodes except deformers), this method returns the name
//  of the plug that inputs the shape data from this
//  node.
//
//  If it does not recognize the node type of the given
//  node, it returns "".
//
//  Currently supported node types:
//   lattice, nurbsSurface, nurbsCurve, mesh, groupParts, deformers,
//   stitchSrf, trim, polyModifier, deleteComponent, makeGroup,
//	 detachSurface
//
global proc string futurePlug(string $node, string $plug)
{
	string $nt = nodeType($node);
	string $futureAttr = "";

	string $testSel[]= `ls -type geometryFilter $node`;
	string $testMM[]= `ls -type polyBase $node`;
	
	if      ($nt == "lattice")		{ $futureAttr = ".wl[0]"; }
	else if ($nt == "nurbsSurface")	{ $futureAttr = ".ws[0]"; }
	else if ($nt == "nurbsCurve") 	{ $futureAttr = ".ws[0]"; }
	else if ($nt == "stitchSrf") 	{ $futureAttr = ".os"; }
	else if ($nt == "trim") 		{ $futureAttr = ".os"; }
	else if ($nt == "untrim") 		{ $futureAttr = ".os"; }	
	else if ($nt == "transformGeometry")   { $historyAttr = ".og"; }
	else if ($nt == "mesh") 		{ $futureAttr = ".w[0]";  }
	else if ($nt == "detachSurface") { $futureAttr = ".os[0]";  }	
	else if ($nt == "groupParts")   { $futureAttr = ".og"; }
	else if ($nt == "makeGroup")    { $futureAttr = ".og"; }
	else if ($nt == "deleteComponent") { $futureAttr = ".og"; }	
	else if (size($testSel)) {
		int $index = plugMultiIndex($plug);
		if ($index == -1) {
			return("");
		}
		$futureAttr = (".og["+$index+"]");
	} else if (size($testMM)) {
		// TdnpolyBase
		//
		$futureAttr = ".output";
	} else {		
		print("Stopped traversing history at plug "+$plug+"\n");
		return("");
	}

	return ($node+$futureAttr);
}

global proc string findGroupParts(string $deformerPlug)
//
//	Description:
//	  Return the groupParts associated with the deformerPlug.
//    This is found by traversing out of the deformer to the
//    groupId and then from the groupId to the groupParts.
//
//	  If no groupParts is found, "" is returned.
//
{
	int $index = plugMultiIndex($deformerPlug);
	if ($index == -1) {
		error("found no index on plug " + $deformerPlug + "\n");
		return("");
	}

	string $buffer[];
	tokenize($deformerPlug,".",$buffer);
	string $groupIdPlug = ($buffer[0]+".input["+$index+"].groupId");

	$buffer = `listConnections $groupIdPlug`;
	if (size($buffer) == 0) {
		return("");
	}

	$buffer = `listConnections ($buffer[0]+".groupId")`;

	for ($node in $buffer) {
		if (nodeType($node) == "groupParts") {
			return $node;
		}
	}
}


// Method: fixHistory(string $shapeName)
//
global proc string fixHistory(string $shapeName, int $unhook)
{
	// get the plug that is feeding this shape its history
	//
	string $obj = $shapeName;
	string $histPlug = historyPlug($obj,"");

	// make sure the object has history before starting the loop
	//
	string $conns[];
	$conns = `listConnections $histPlug`;
	if (! size($conns)) {
		print($obj + " has no history.\n");
		return "";
	}

	// resultNodes = all the nodes that are traversed
	//
	// gpNodes = groupParts node connected to the groupId that is
	//           connected to the corresponding deformPlug
	// deformPlugs = see gpNodes
	// gpGpList = all the groupParts we traverse
	// gpSetList = set corresponding to groupParts in gpGpList
	// gpIdList = id corresponding to groupParts in gpGpList
	// 
	//
	string $resultNodes[];
	string $gpNodes[];
	string $deformPlugs[];	
	string $gpGpList[];
	string $gpSetList[];
	string $gpIdList[];
	
	int $count = 0;
	while (true) {
		// get the name of the upstream node
		//		
		$conns = `listConnections $histPlug`;
		if (0 == size($conns)) {
			// stop, we can't find any more history
			//
			break;
		}

		// get the name of the upstream plug
		//
		$conns = `listConnections -p true $histPlug`;

		// listConnections returns transform name for shapes, so make
		// sure we get the node name and not the transform
		//
		string $buffer[];
		tokenize($conns[0],".",$buffer);
		$obj = $buffer[0];

		// get the name of the plug feeding the shape into this node
		//
		$histPlug = historyPlug($obj,$conns[0]);
		if ($histPlug == "") {
			// stop, we can't find any more history
			//
			break;
		}

		// keep track of which groupParts controls
		// the groupId attached to the deformer
		//
		string $nt[] = `ls -type "geometryFilter" $obj`;
		if (size($nt)) {
			int $gpLength = size($gpNodes);
			$gpNodes[$gpLength] = findGroupParts($conns[0]);
			$deformPlugs[$gpLength] = $conns[0];
		}

		//
		// keep track of all the nodes we traverse
		//
		int $rlength = size($resultNodes);
		$resultNodes[$rlength] = $obj;
		
		//
		// for each groupParts node, store its set and its id
		//
		if (nodeType($obj) == "groupParts") {
			$conns = `listConnections ($obj+".groupId")`;
			if (size($conns)) {
				int $glength = size($gpGpList);
				int $deformerSet = 0;
				string $idName = $conns[0];
				$conns = `listConnections (($conns[0])+".message")`;
				if (size($conns)) {
					string $setName = $conns[0];
					$conns = `listConnections ($setName+(".ub"))`;
					if (size($conns)) {
						$gpSetList[$glength] = $setName;
						$gpGpList[$glength] = $obj;
						$gpIdList[$glength] = $idName;
					}
				}
			}
		}
		$count++;
	}

	int $ii, $jj, $kk;
	int $warnCount = 0;
	string $restoreSetsCmd;
	if (! $unhook) {
		for ($ii = 0; $ii < size($gpGpList); $ii++) {
			int $countSets = 0;
			int $modIndices[];
			string $currentSet = $gpSetList[$ii];
			for ($kk = 0; $kk < $ii; $kk++) {
				if ($gpSetList[$kk] == $currentSet) {
					$countSets = 1;
					break;
				}
			}
			if ($countSets) continue;
			
			$countSets = 0;
			for ($jj = 0; $jj < size($gpSetList); $jj++) {
				if ($currentSet == $gpSetList[$jj]) {
					$modIndices[$countSets] = $jj;
					$countSets++;
				}
			}
			
			string $conns[] = `listConnections ($gpSetList[$ii]+".ub")`;
			string $deformer = $conns[0];
			if ($countSets > 1) {
				$warnCount++;
				$restoreSetsCmd += ("\tsets -add "+$gpSetList[$ii]+" ");
				string $members[] = `sets -q $gpSetList[$ii]`;
				for ($mem in $members) {
					$restoreSetsCmd += ($mem+" ");
				}
				$restoreSetsCmd += ";";

				if ($warnCount == 1) {
					print("\n");
				}
				string $deleteCmd = "\tdelete ";
				for ($jj = 0; $jj < $countSets; $jj++) {
					$deleteCmd += ($gpGpList[$modIndices[$jj]] + " ");
				}
				$deleteCmd += ";";
				evalEcho $deleteCmd;
			}
		}
	}
	else {
		// print out information on unnecessary connections
		//
		for ($ii = 0; $ii < size($gpNodes); $ii++) {
			if ($gpNodes[$ii] == "") {
				$warnCount++;
				string $buffer[];
				tokenize($deformPlugs[$ii],".",$buffer);
				int $index = plugMultiIndex($deformPlugs[$ii]);
				string $unhookCmd = ("\tunhookIndexedDeformer "+ $buffer[0] + " " + $index + ";\n");
				evalEcho $unhookCmd;
				$restoreSetsCmd = "success";
			}
		}
	}
	return $restoreSetsCmd;
}

global proc fixSets()
//
// Method: fixSets()
// Description: searches for and fixes problems that could cause problems
//				editing set membership
// To use: Select shape (or shapes) and enter fixSets in the ScriptEditor.
//	       Results are printed in the ScriptEditor.
//
{
	// get the selected item
	//
	string $currSel[] = `ls -selection -dag -shapes`;

	if (0 == size($currSel)) {
		error("Select the items to test.\n");
		return;
	}

	print("=========================================\n");
	int $foundShape = 0;
	for ($sel in $currSel) {
		string $cpcheck[] = `ls -type controlPoint $sel`;
		if (size($cpcheck)) {
			int $interObject = `getAttr ($sel+".io")`;
			if (! $interObject) {
				$foundShape++;
				print("\n"+$foundShape+". "+$sel);
				if (shapeHasDeformationHistory($sel)) {
					string $restoreSets = fixHistory($sel,0);
					string $done = fixHistory($sel,1);
					if (size($restoreSets)) {
						if (catch(`evalEcho $restoreSets`)) {
							print("// Warning: Some sets contents may be slightly modified.\n");
						}
					} else if (size($done) == 0) {
						print(": no problems were detected.\n");
					}
				} else {
					print(": no deformations in history.\n");
				}
			}
		}
	}
	
	if (! $foundShape) {
		error("Selection contained no shapes to test.\n");
		return;
	}

}
