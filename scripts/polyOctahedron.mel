//
// Copyright (C) 1997-1998 Alias|Wavefront,
// a division of Silicon Graphics Limited.
//
// The information in this file is provided for the exclusive use of the
// licensees of Alias|Wavefront.  Such users have the right to use, modify,
// and incorporate this code into other products for purposes authorized
// by the Alias|Wavefront license agreement, without fee.
//
// ALIAS|WAVEFRONT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
// INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
// EVENT SHALL ALIAS|WAVEFRONT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
// CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
// DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.
//
// Alias|Wavefront Script File
// MODIFY THIS AT YOUR OWN RISK
//
// Description : Given the length of edge, construct an octahedron
//

// Find the radius of circle encompasing the polygon. 
//
proc float boundingCircleRadius( int $n, float $x )
//
//	Description:
//		number of sides on the polygon.
//		$x = length of the polygon.
//
{
	float $rad ;
	float $angle = 360.0 / $n ;

	float $cosx = cos(deg_to_rad($angle)) ; 	
	float $den = 2.0 * ( 1.0 - $cosx ) ;
	$rad = $x / sqrt($den) ;
	return $rad ;
}

proc float[] createRegularPolygonX( int $n, float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;

	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * cos(deg_to_rad($a)) ;
	}
	return $x ;	
}

proc float[] createRegularPolygonY( int $n,float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * sin(deg_to_rad($a)) ;
	}
	return $x ;	
}


global proc int polyOctahedron( float $len )
{

	int $n = 4 ;
	float $r = boundingCircleRadius( $n, $len ) ;

	float $x[] = createRegularPolygonX( $n, $r ) ;
	float $y[] = createRegularPolygonY( $n, $r ) ;


	float $p1x, $p1y, $p1z ; 	
	float $p2x, $p2y, $p2z ; 	

	// top half.
	//	
	$p1x = 0.0 ;	
	$p1y = 0.0 ;	
	$p1z = sqrt( $len*$len - $r*$r);	

	float $z = 0.0 ;
	string $facet1[] ;
	$facet1 = `polyCreateFacet -ch 0 -p $p1x $p1y $p1z -p $x[0] $y[0] $z -p $x[1] $y[1] $z` ;
	
	string $facet2[] ;
	$facet2 = `polyCreateFacet -ch 0 -p $p1x $p1y $p1z -p $x[1] $y[1] $z -p $x[2] $y[2] $z` ;

	string $facet3[] ;
	$facet3 = `polyCreateFacet -ch 0 -p $p1x $p1y $p1z -p $x[2] $y[2] $z -p $x[3] $y[3] $z` ;

	string $facet4[] ;
	$facet4 = `polyCreateFacet -ch 0 -p $p1x $p1y $p1z -p $x[3] $y[3] $z -p $x[0] $y[0] $z` ;

	// bottom half.
	//
	$p2x = 0.0 ;	
	$p2y = 0.0 ;	
	$p2z = -1.0 * $p1z;	

	string $facet5[] ;
	$facet5 = `polyCreateFacet -ch 0 -p $x[0] $y[0] $z -p $p2x $p2y $p2z -p $x[1] $y[1] $z` ;

	string $facet6[] ;
	$facet6 = `polyCreateFacet -ch 0 -p $x[1] $y[1] $z -p $p2x $p2y $p2z -p $x[2] $y[2] $z` ;

	string $facet7[] ;
	$facet7 = `polyCreateFacet -ch 0 -p $x[2] $y[2] $z -p $p2x $p2y $p2z -p $x[3] $y[3] $z` ;

	string $facet8[] ;
	$facet8 = `polyCreateFacet -ch 0 -p $x[3] $y[3] $z -p $p2x $p2y $p2z -p $x[0] $y[0] $z` ;

	string $octa[] ;
	$octa = `polyUnite -ch 0 $facet1[0] $facet2[0] $facet3[0] $facet4[0] $facet5[0] $facet6[0] $facet7[0] $facet8[0]` ;

	select -r $octa[0] ;
	return 0 ;

}

