#!/bin/env python
# vim:ts=4:sw=4:expandtab

# sharc, a shader archiver
# by pink

from pymel.core import *
import maya.cmds as mc
import sys
import os
import uuid
import json

class memoized(object):
    """Decorator that caches a function's return value each time it is called.
    If called later with the same arguments, the cached value is returned, and
    not re-evaluated.
    """
    def __init__(self, func):
       self.func = func
       self.cache = {}
    def __call__(self, *args):
       try:
          return self.cache[args]
       except KeyError:
          value = self.func(*args)
          self.cache[args] = value
          return value
       except TypeError:
          # uncachable -- for instance, passing a list as an argument.
          # Better to not cache than to blow up entirely.
          return self.func(*args)
    def __repr__(self):
       """Return the function's docstring."""
       return self.func.__doc__
    def __get__(self, obj, objtype):
       """Support instance methods."""
       return functools.partial(self.__call__, obj)

def mklist(obj):
    if isinstance(obj,list):
        return obj
    return list([obj])

def sg_for_geo(geos):
    sgs = []
    geos = mklist(geos)
    for geo in geos:
        for sg in listConnections(geo,type='shadingEngine'):
            sgs.append(sg)
    return sgs
    
def shape(objs):
    """Returns the shape node (if passed a transform for instance.)"""
    result = None
    if objs:
        result = listRelatives(objs,s=1,ni=1)
    return result

def assign_uuid(objs):
    i = 0
    result = list()
    for obj in mklist(objs):
        if not obj.hasAttr('uuid'):
            luuid = uuid.uuid4()
            addAttr(obj, dt='string', sn='uuid')
            setAttr(obj+'.uuid', luuid, type='string')
            setAttr(obj+'.uuid', lock=1)
            i += 1
            result.append(obj)
    if i > 0:
        print('Assigned uuid to '+str(i)+' things.')
    return result

def build_shader_dict(geos):
    """Returns a dictionary.
    The keys are the shape-object-uuid and the value is the sg-uuid."""
    shaderDict = dict()
    for geo in mklist(geos):
        assign_uuid(geo)
        sg = sg_for_geo(geo)[0]
        assign_uuid(sg)
        shaderDict[geo.getAttr('uuid')] = sg.getAttr('uuid')
    return shaderDict

def write_maya():
    # make some easy to use names
    mayafilepath = mc.file(q=1,sn=1)
    mayafilename = os.path.basename(mc.file(q=1,sn=1)).split('.')[0]
    currentRenderLayer = mc.editRenderLayerGlobals(q=1,crl=1)
    
    # file specfic names
    fp = os.path.dirname(mayafilepath)+'/'+mayafilename+'_'+currentRenderLayer
    melfile = fp+'_sharc.mel'
    shadersfile = fp+'_sharc_shaders.mb'
    cleanfile = fp+'_sharc_clean.mb'

    # create a locator that stores the important infos
    loc = mc.spaceLocator(n='sharc_'+currentRenderLayer)
    mc.addAttr(loc[0],ln='sharcMEL',dt='string')
    mc.setAttr(loc[0]+'.sharcMEL',melfile,type='string')
    mc.addAttr(loc[0],ln='sharcShaders',dt='string')
    mc.setAttr(loc[0]+'.sharcShaders',shadersfile,type='string')
    mc.addAttr(loc[0],ln='sharcOriginal',dt='string')
    mc.setAttr(loc[0]+'.sharcOriginal',mayafilepath,type='string')

    # Make a file handle and write headers
    outf = file(melfile, 'w')
    outf.write('// MEL auto-generated by sharc for '+mayafilepath+'\n')
    outf.write('file -i -ra false -lnr -op "v=0" "'+shadersfile+'";\n')

    # get our shading groups
    sgs = mklist(mc.ls(type='shadingEngine'))
    for sg in sgs:
        mc.hyperShade(objects=sg)
        objs = mc.ls(sl=1,fl=1,l=1)
        if not objs:
            continue
        count = 0
        for obj in objs:
            if count == 0:
                cmd = 'select -r '+obj+';\n'
            else:
                cmd = 'select -add '+obj+';\n'
            outf.write(cmd)
            count += 1
        cmd = 'sets -e -fe '+sg+';\n'
        outf.write(cmd)

    outf.write('\n')
    outf.close()
    print('// sharc.py Wrote '+melfile)

    # Export Shaders to a Maya file
    print('// sharc.py Exporting Shaders to '+shadersfile)
    mc.select(sgs,ne=1)
    mc.file(shadersfile,force=1,options='v=0',type='mayaBinary',exportSelected=1);

    # Optionally clean the shaders out of this file.
    answer = mc.confirmDialog(title='Sharc Question', message='Save a no-shaders version of file?', button=['Yes','No'], defaultButton='Yes')
    if answer == "yes":
        print '// sharc.py Saving current file as '+cleanfile
        mc.select(sgs,ne=1)
        mc.select(('initialShadingGroup','initialParticleSE'),d=1,ne=1)
        mc.delete(mc.ls(sl=1))
        mc.file(rename=cleanfile)
        mc.file(f=1,save=1,options="v=0",type='mayaBinary')

def write_json(out_filename=''):
    json_filename = out_filename
    if json_filename == '':
        # make some easy to use names
        mayafilepath = mc.file(q=1,sn=1)
        mayafilename = os.path.basename(mc.file(q=1,sn=1)).split('.')[0]
        currentRenderLayer = mc.editRenderLayerGlobals(q=1,crl=1)
        # file specfic names
        fp = os.path.dirname(mayafilepath)+'/'+mayafilename+'_'+currentRenderLayer
        json_filename = fp+'_sharc.json'

#    sgs = mc.ls(sl=1,type=['shadingEngine'])
        
    geos = shape(selected())
    geos = ls(geos,type=['mesh','nurbsSurface','subdiv'])
    
    if geos:
        shader_dict = build_shader_dict(geos)
        jsonf = file(out_filename, 'w')
        json.dump(shader_dict,jsonf,indent=0)
        jsonf.close()
        print('// sharc.py : Exported shader attachments to '+json_filename)
        return True
    else:
        mel.warning('Nothing to do. Select geometry(s) or shadingEngine(s).')
        return False

def read_json(filename):
    jsonf = open(filename, 'r')
    shader_dict = json.load(jsonf)
    for k, v in shader_dict.iteritems():
        sets(obj_for_uuid(v),forceElement=obj_for_uuid(k))

@memoized
def obj_for_uuid(uuid_query):
    acc = list()
    objs = ls(type=['mesh','nurbsSurface','subdiv','shadingEngine'])
    for obj in objs:
        if obj.hasAttr('uuid'):
            if obj.getAttr('uuid') == uuid_query:
                print obj
                return obj
                acc.append(obj)
    return acc                

def main():
    write_maya()
    write_json()
    
if __name__ == '__main__':
    main()
