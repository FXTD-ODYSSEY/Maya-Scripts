//
// Copyright (C) 1997-1998 Alias|Wavefront,
// a division of Silicon Graphics Limited.
//
// The information in this file is provided for the exclusive use of the
// licensees of Alias|Wavefront.  Such users have the right to use, modify,
// and incorporate this code into other products for purposes authorized
// by the Alias|Wavefront license agreement, without fee.
//
// ALIAS|WAVEFRONT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
// INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
// EVENT SHALL ALIAS|WAVEFRONT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
// CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
// DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.
//
// Alias|Wavefront Script File
// MODIFY THIS AT YOUR OWN RISK
//
//
// Description : Construct an icosahedron given the length of the edge.
// example: polyIcosahedron 3

proc int remainder( int $x, int $y )
//
//
{
	int $q = $x/$y ;
	return $x - $q*$y   ;
}
// Find the radius of circle encompasing the polygon. 
//
proc float boundingCircleRadius( int $n, float $x )
//
//	Description:
//		number of sides on the polygon.
//		$x = length of the polygon.
//
{
	float $rad ;
	float $angle = 360.0 / $n ;

	float $cosx = cos(deg_to_rad($angle)) ; 	
	float $den = 2.0 * ( 1.0 - $cosx ) ;
	$rad = $x / sqrt($den) ;
	return $rad ;
}

proc float[] createRegularPolygonX( int $n, float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;

	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * cos(deg_to_rad($a)) ;
	}
	return $x ;	
}

proc float[] createRegularPolygonY( int $n,float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * sin(deg_to_rad($a)) ;
	}
	return $x ;	
}

proc pyramid( float $x[], float $y[], float $z[] )
//
//	Description :
//
{

}

global proc int polyIcosahedron( float $len )

{
	int $i ;
	int $n = 5 ;
	float $zp1[5] ;
	float $r = boundingCircleRadius( $n, $len ) ;

	// first pentagon.
	float $xp1[] = createRegularPolygonX( $n, $r ) ;
	float $yp1[] = createRegularPolygonY( $n, $r ) ;
	for( $i = 0 ; $i < $n ; $i++ ) $zp1[$i] = 0.0 ;

	// second pentagon.
	float $zp2[5] ;
	float $xp2[] = createRegularPolygonX( $n, -1.0 * $r ) ;
	float $yp2[] = createRegularPolygonY( $n, -1.0 * $r ) ;
	float $dx =  ( $xp2[0] - $xp1[2] ) ;
	float $dy =  ( $yp2[0] - $yp1[2] ) ;
	float $rhs = $len*$len - $dx*$dx - $dy*$dy ;
	float $z = sqrt(abs($rhs)); 
	for( $i = 0 ; $i < $n ; $i++ ) $zp2[$i] = $z ;



	// create triangles.
	//
	string $facets[] ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		int $k ;
		int $i1 = $i+2 ;
		int $i2 = $i1+1 ;
		$i1 = remainder( $i1, $n ) ;	
		$i2 = remainder( $i2, $n ) ;	
		string $tmpFacets[] ;
		$tmpFacets = `polyCreateFacet -ch 0 -p $xp1[$i1] $yp1[$i1] $zp1[$i1] -p $xp1[$i2] $yp1[$i2] $zp1[$i2] -p $xp2[$i] $yp2[$i] $zp2[$i]`;		
		int $l = size($facets) ;
		for( $k = 0 ; $k < size($tmpFacets) ; $k++ ) {
			$facets[$l++] = $tmpFacets[$k] ;
		}
		int $i3 = remainder($i+1,$n) ;	
		$tmpFacets = `polyCreateFacet -ch 0 -p $xp1[$i2] $yp1[$i2] $zp1[$i2] -p $xp2[$i3] $yp2[$i3] $zp2[$i3] -p $xp2[$i] $yp2[$i] $zp2[$i]`;
		$l = size($facets) ;
		for( $k = 0 ; $k < size($tmpFacets) ; $k++ ) {
			$facets[$l++] = $tmpFacets[$k] ;
		}
	}

	string $ico[] ;	
	// unite.
	//
	string $part1[] ;	
	select -r $facets ;
	$part1 = `polyUnite -ch 0` ;


	// top pentagonal pyramid.
	//
	$z = $len*$len - ($xp1[0]*$xp1[0] + $yp1[0]*$yp1[0]) ;
	$z = -1.0 * sqrt(abs($z)) ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		int $k ;
		float $x = 0.0 ;
		float $y = 0.0 ;
		string $tmpFacets[] ;
		int $i1 = remainder($i+1,$n) ;
		$tmpFacets = `polyCreateFacet -ch 0 -p $xp1[$i] $yp1[$i] $zp1[$i] -p $x $y $z -p $xp1[$i1] $yp1[$i1] $zp1[$i1]`; 
		int $l = size($facets) ;
		for( $k = 0 ; $k < size($tmpFacets) ; $k++ ) {
			$facets[$l++] = $tmpFacets[$k] ;
		}
	}
	string $part2[] ;	
	select -r $facets ;
	$part2 = `polyUnite -ch 0` ;

	// bottom pentagonal pyramid.
	//
	float $zt = $len*$len - ($xp2[0]*$xp2[0] + $yp2[0]*$yp2[0] ) ;
	$z = sqrt(abs($zt)) + $zp2[0] ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		int $k ;
		float $x = 0.0 ;
		float $y = 0.0 ;
		string $tmpFacets[] ;
		int $i1 = remainder($i+1,$n) ;
		$tmpFacets = `polyCreateFacet -ch 0 -p $x $y $z -p $xp2[$i] $yp2[$i] $zp2[$i] -p $xp2[$i1] $yp2[$i1] $zp2[$i1]`; 
		int $l = size($facets) ;
		for( $k = 0 ; $k < size($tmpFacets) ; $k++ ) {
			$facets[$l++] = $tmpFacets[$k] ;
		}
	}

	// atlast the polyhedron.
	//
	string $part3[] ;	
	select -r $facets ;
	$part3 = `polyUnite -ch 0` ;
	string $ico[] = `polyUnite -ch 0 $part1[0] $part2[0] $part3[0]` ;
	
	select -r $ico[0] ; 
		
	return 0 ;
}


