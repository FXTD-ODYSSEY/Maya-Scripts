//
// Copyright (C) 1997-1998 Alias|Wavefront,
// a division of Silicon Graphics Limited.
//
// The information in this file is provided for the exclusive use of the
// licensees of Alias|Wavefront.  Such users have the right to use, modify,
// and incorporate this code into other products for purposes authorized
// by the Alias|Wavefront license agreement, without fee.
//
// ALIAS|WAVEFRONT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
// INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
// EVENT SHALL ALIAS|WAVEFRONT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
// CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
// DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.
//
// Alias|Wavefront Script File
// MODIFY THIS AT YOUR OWN RISK
//
//  Procedure Name:
//      hardwareTxEditor
//
//  Creation Date:  06 February 1998
//  Author:         cdt
//
//  Description:
//  This implements the hardware texture editor.
//	Place this script some where in your script path
//	(typically "~/maya/scripts/"), start Maya and type "hardwareTxEditor".
//	A window will be displayed and any object you select will update the window
//	to show which hardware texture channel is displayed.
//	You can also adjust the quality of the texture.
//  Note:
//  This script is suitable for use ONLY with Maya 1.0 or 1.0.1
//  It would need modifications to work properly under any later release,
//  due to changes in how textures get connected within the scene.


proc getSelectionShadingGroups( string $selection[], string $shadingGroups[] )
{
    for ($i = 0; $i < size($selection); $i += 2) {
        string $object = $selection[$i];
        string $type = $selection[$i + 1];

        string $groups[];

        if ($type == "transform") {
            string $shapes[] = `listRelatives -shapes $object`;
            if (size($shapes) == 0) continue;
            $groups = `listConnections ($shapes[0]+".instObjGroups")`;
        }
        else if ($type == "nurbsSurface" || $type == "mesh") {
            $groups = `listConnections ($object+".instObjGroups")`;
        }

        // Add each group to the list of shading groups

        for ($item in $groups) {
            if (`objectType $item` == "shadingEngine")
                $shadingGroups[size($shadingGroups)] = $item;
        }
    }
}

proc string selectionMaterialInfo()
{
    string $result = "";

    string $shadingGroups[];
    string $selection[] = `ls -selection -showType`;
    getSelectionShadingGroups($selection, $shadingGroups);

    if (size($shadingGroups) > 0) {
        // Only process the first surface item;
        string $shadingGroup = $shadingGroups[0];

        string $messages[] = `listConnections ($shadingGroup+".message")`;

        for ($item in $messages) {
            if (`objectType $item` == "materialInfo") {
                $result = $item;
                break;
            }
        }
    }

    return $result;
}

proc string materialConnectionAttr(string $material, string $texture)
{
    if ($material == "" || $texture == "")
        return "";

    // Get all the connections on the output attributes of the
    // texture. One of these should be connected to the material.

    string $connections[] =
        `listConnections -plugs true -source false -destination true $texture`;

    // Determine which plug is connected to the material.

    for ($item in $connections) {
        string $buffer[];
        tokenize($item, ".", $buffer);
        if (size($buffer) < 2) continue;

        string $materialType = `objectType $buffer[0]`;

        if ($materialType == "bump2d" || $materialType == "bump3d") {
            // Skip the texture and process the bump.
            return materialConnectionAttr($material, $buffer[0]);
        }

        if ($buffer[0] == $material)
            return $buffer[1];
    }

    return "";
}

proc string textureConnectionAttr(string $material, string $texture)
{
    // Get all the connections on the output attributes of the
    // texture. One of these should be connected to the material.

    string $connections[] = `listConnections -connections true
        -source false -destination true $texture`;

    // Determine which connection is connected to the material.

    for ($i = 0; $i < size($connections); $i += 2) {
        if ($connections[$i+1] == $material) {
            string $buffer[];
            tokenize($connections[$i], ".", $buffer);
            if (size($buffer) < 2) continue;

            return $buffer[1];
        }
    }

    return "";
}

proc string bumpTextureNode( string $bump )
{
    string $texture = "";

    // Skip the bump node to get the texture.

    string $bumpType = `objectType $bump`;

    if ($bumpType == "bump2d" || $bumpType == "bump3d") {
        string $connections[] = `listConnections -source true
            -destination false ($bump+".bumpValue")`;

        if (size($connections) > 0) {
            $texture = $connections[0];
            string $textureType = `objectType $texture`;

            // Does the network already have surface shader quality ?
            if ($textureType != "surfaceShader") {
                // Insert a surface shader node

                disconnectAttr ($texture+".outAlpha") ($bump+".bumpValue");

                // Insert a node to pass outAlpha.
                string $quality = `shadingNode -name ($texture+"Quality")
                    -asShader surfaceShader`;
                addAttr -ln outAlpha -at "float" -dv 0.0 $quality;
                connectAttr ($texture+".outAlpha") ($quality+".outColorR");
                connectAttr ($texture+".outAlpha") ($quality+".outColorG");
                connectAttr ($texture+".outAlpha") ($quality+".outColorB");
                connectAttr ($texture+".outAlpha") ($quality+".outAlpha");
                connectAttr ($quality+".outAlpha") ($bump+".bumpValue");

                //
                // We will now have:
                //
                // Shader <- Bump <- SurfaceShader <- Texture
                //

                $texture = $quality;
            }
        }
    }

    return $texture;
}

proc updateChannelMenu( string $parent )
{
    setParent $parent;

    int $hasColor = false;
    int $hasTransparency = false;
    int $hasAmbientColor = false;
    int $hasIncandescence = false;
    int $hasNormalCamera = false;
    int $hasSpecularColor = false;
    int $hasReflectedColor = false;
    int $hasWhiteness = false;

    string $material = `textFieldGrp -q -text material`;

    string $attrs[] = `listAttr -write $material`;

    for ($item in $attrs) {
        switch ($item) {
        case "color":
            $hasColor = true;
            break;
        case "transparency":
            $hasTransparency = true;
            break;
        case "ambientColor":
            $hasAmbientColor = true;
            break;
        case "incandescence":
            $hasIncandescence = true;
            break;
        case "normalCamera":    // bump map
            $hasNormalCamera = true;
            break;
        case "specularColor":
            $hasSpecularColor = true;
            break;
        case "reflectedColor":
            $hasReflectedColor = true;
            break;
        case "whiteness":
            $hasWhiteness = true;
            break;
        }
    }

    menuItem -e -enable $hasColor c2;
    menuItem -e -enable $hasTransparency c3;
    menuItem -e -enable $hasAmbientColor c4;
    menuItem -e -enable $hasIncandescence c5;
    menuItem -e -enable $hasNormalCamera c6;
    menuItem -e -enable $hasSpecularColor c7;
    menuItem -e -enable $hasReflectedColor c8;
    menuItem -e -enable $hasWhiteness c9;
}

proc updateQualityMenu( string $parent )
{
    setParent $parent;

    string $texture = `textFieldGrp -q -text texture`;

    if ($texture != "") {
        int $index = 1;         // low

        string $buffer[] = `listAttr -string resolution $texture`;

        // Does the texture have a resolution attribute ?
        if (size($buffer) != 0) {
            int $resolution = `getAttr ($texture+".resolution")`;

            if ($resolution >= 256)
                $index = 4;     // highest
            else if ($resolution >= 128)
                $index = 3;     // high
            else if ($resolution >= 64)
                $index = 2;     // medium
        }

        optionMenuGrp -e -select $index quality;
    }
}

//
//  Procedure Name:
//      hardwareTxEditorSelectionCB
//
//  Description:
//      The active list has changed update the controls. We only
//      process the first selection.
//
//  Input Arguments:
//      Name of the parent control.
//
//  Return Value:
//      None.
//
global proc hardwareTxEditorSelectionCB( string $parent )
{
    setParent $parent;

    // Get the material info from the selection list.
    string $info = selectionMaterialInfo();
    textFieldGrp -e -text $info materialInfo;

    if ($info == "") {
        textFieldGrp -e -text "" material;
        textFieldGrp -e -text "" texture;
        optionMenuGrp -e -select 1 materialChannel;
        return;
    }

    // Get the materialInfo shader
    string $connections[] = `listConnections ($info+".material")`;
    string $material = (size($connections) == 0) ? "" : $connections[0];
    textFieldGrp -e -text $material material;

    // Get the materialInfo texture
    $connections = `listConnections ($info+".texture")`;
    string $texture = (size($connections) == 0) ? "" : $connections[0];
    textFieldGrp -e -text $texture texture;

    // Get the material attribute used between the nodes.
    string $attr = materialConnectionAttr($material, $texture);

    if ($attr != "") {
        int $index = 1;         // none

        switch ($attr) {
        case "color":
            $index = 2;
            break;
        case "transparency":
            $index = 3;
            break;
        case "ambientColor":
            $index = 4;
            break;
        case "incandescence":
            $index = 5;
            break;
        case "normalCamera":    // bump map
            $index = 6;
            break;
        case "specularColor":
            $index = 7;
            break;
        case "reflectedColor":
            $index = 8;
            break;
        case "whiteness":
            $index = 9;
            break;
        }

        optionMenuGrp -e -select $index materialChannel;
    }

    updateChannelMenu( $parent );
    updateQualityMenu( $parent );
}

//
//  Procedure Name:
//      hardwareTxEditorChannelCB
//
//  Description:
//      The user has updated the channel menu. This procedure will modify
//      materialInfo texture connection.
//
//  Input Arguments:
//      Name of the parent control.
//
//  Return Value:
//      None.
//
global proc hardwareTxEditorChannelCB( string $parent )
{
    setParent $parent;

    // Get the material info node.
    string $info = `textFieldGrp -q -text materialInfo`;
    if ($info == "") return;

    // Disconnect the current texture from materialInfo
    //

    string $connections[] = `listConnections -plugs true ($info+".texture")`;

    for ($item in $connections) {
        disconnectAttr $item ($info+".texture");
    }

    // Get the material channel to now display.
    //

    int $index = `optionMenuGrp -q -select materialChannel`;

    string $attribute = "";

    switch ($index) {
    case 2:
        $attribute = "color";
        break;
    case 3:
        $attribute = "transparency";
        break;
    case 4:
        $attribute = "ambientColor";
        break;
    case 5:
        $attribute = "incandescence";
        break;
    case 6:                     // bump map
        $attribute = "normalCamera";
        break;
    case 7:
        $attribute = "specularColor";
        break;
    case 8:
        $attribute = "reflectedColor";
        break;
    case 9:
        $attribute = "whiteness";
        break;
    }

    // Connect up the new texture to materialInfo.
    //

    if ($attribute != "") {
        string $material = `textFieldGrp -q -text material`;

        // Get the connections on the mapped channel.
        string $connections[] = `listConnections -source true
            -destination false ($material+"."+$attribute)`;

        // Did user switch to the bump channel ?
        if (size($connections) > 0 && $attribute == "normalCamera") {
            // Insert a surface shader if necessary, and get the
            // texture associated with this bump.

            string $texture = bumpTextureNode($connections[0]);

            clear($connections);

            if ($texture != "") $connections[0] = $texture;
        }

        if (size($connections) > 0) {
            connectAttr ($connections[0]+".message") ($info+".texture");
            textFieldGrp -e -text $connections[0] texture;
            updateQualityMenu( $parent );
        }
    }
}

//
//  Procedure Name:
//      hardwareTxEditorQualityCB
//
//  Description:
//      The user has updated the quality menu. Update the resolution
//      attribute, and add a surface shader node if necessary.
//
//  Input Arguments:
//      Name of the parent control.
//
//  Return Value:
//      None.
//
global proc hardwareTxEditorQualityCB( string $parent )
{
    setParent $parent;

    string $texture = `textFieldGrp -q -text texture`;

    if ($texture != "") {
        string $type = `objectType $texture`;

        if ($type == "file") {
            string $result = `confirmDialog
                -title "Update fileTexture quality"
                -message ("Modifying a file texture's quality will\n"+
                          "disable hardware texture cycling and fast\n"+
                          "2D texture placement. Continue with operation?")
                -button "Yes" -button "No"
                -defaultButton "Yes" -cancelButton "No"`;

            // Unfortunately, we cannot reset the option menu, because
            // its value isn't set until return from this proc.
            if ($result != "Yes") return;
        }

        if ($type == "bulge" || $type == "checker" || $type == "cloth" ||
            $type == "file" || $type == "fractal" || $type == "grid" ||
            $type == "mountain" || $type == "ramp" || $type == "water")
        {
            // Insert a surface shader between the shader and
            // texture. Hardware texturing will treat this as a
            // plug-in and use convert solid texture to generate the
            // texture map. The convert solid process uses an
            // attribute named resolution to determine the quality.

            string $info = `textFieldGrp -q -text materialInfo`;
            string $material = `textFieldGrp -q -text material`;
            string $attr = materialConnectionAttr($material, $texture);

            if ($attr != "" && $attr != "normalCamera") {
                // Assume the texture output is outColor.
                //
                // Disconnect the texture from the material, insert a
                // surface shader, and reconnect to the material.

                disconnectAttr ($texture+".outColor") ($material+"."+$attr);

                // Insert a node to pass outColor.
                string $quality = `shadingNode -name ($texture+"Quality")
                    -asShader surfaceShader`;
                connectAttr ($texture+".outColor") ($quality+".outColor");
                connectAttr ($quality+".outColor") ($material+"."+$attr);

                //
                // We now have:
                //
                // Shader <- SurfaceShader <- Texture
                //                  ^
                //    MaterialInfo--+
                //

                textFieldGrp -e -text $quality texture;

                $texture = $quality;
            }
        }

        // Create a resolution attribute if one doesn't exist
        //

        string $buffer[] = `listAttr -string resolution $texture`;

        if (size($buffer) == 0) {
            addAttr -ln resolution -at long -dv 32 $texture;
        }

        // Set the resolution attribute on the texture depending on
        // the quality the user specified.
        //

        int $index = `optionMenuGrp -q -select quality`;

        switch ($index) {
        case 1:                 // low
            setAttr ($texture+".resolution") 32;
            break;
        case 2:                 // medium
            setAttr ($texture+".resolution") 64;
            break;
        case 3:                 // high
            setAttr ($texture+".resolution") 128;
            break;
        case 4:                 // highest
            setAttr ($texture+".resolution") 256;
            break;
        }
    }
}

global proc hardwareTxEditor()
{
    if (`window -exists hardwareTxEditor`) {
        showWindow hardwareTxEditor;
        return;
    }

    string $window = `window -resizeToFitChildren true hardwareTxEditor`;

        columnLayout -adj true;
            textFieldGrp -label "Material info" -editable false materialInfo;

            separator -height 25;

            textFieldGrp -label "Material" -editable false material;

            optionMenuGrp -label "Material channel"
                    -cc ("hardwareTxEditorChannelCB "+$window) materialChannel;
                menuItem -label "None" c1;
                menuItem -label "Color" c2;
                menuItem -label "Transparency" c3;
                menuItem -label "Ambient Color" c4;
                menuItem -label "Incandescence" c5;
                menuItem -label "Bump Mapping" c6;
                menuItem -label "Specular Color" c7; // phong, blinn, phongE
                menuItem -label "Reflected Color" c8; // phong, blinn, phongE
                menuItem -label "Whiteness" c9; // phongE
            setParent ..;

            textFieldGrp -label "Texture" -editable false texture;

            optionMenuGrp -label "Texture quality"
                    -cc ("hardwareTxEditorQualityCB "+$window) quality;
                menuItem -label "Low";
                menuItem -label "Medium";
                menuItem -label "High";
                menuItem -label "Highest";
            setParent ..;

    // Create a script job so that we can monitor changes on the
    // selection list. Its attached to the hardware texture editor.

    scriptJob -parent $window
        -event SelectionChanged ("hardwareTxEditorSelectionCB "+$window);

    // Update the controls with current selection list.
    hardwareTxEditorSelectionCB($window);

    showWindow;
}
